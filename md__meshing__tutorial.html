<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xmsmesh: Meshing_Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xmsmesh
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__meshing__tutorial.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Meshing_Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Meshing_Tutorial">Meshing Tutorial</a><ul><li class="level2"><a href="#Intro_Meshing">Introduction</a></li>
<li class="level2"><a href="#Example_Simple_Polygon">Example - Simple Polygon</a></li>
<li class="level2"><a href="#Example_Complex_Polygon">Example - Complex Polygon</a></li>
<li class="level2"><a href="#Example_Complex_Polygon_Hole">Example - Simple Polygon with a hole</a></li>
<li class="level2"><a href="#Example_Breaklines">Example - Breaklines</a></li>
<li class="level2"><a href="#Example_RefinePoints">Example - Refine Points</a></li>
<li class="level2"><a href="#Example_MultiPolygon">Example - Multiple Polygons with variable spacing, holes, breaklines, and refine points</a></li>
<li class="level2"><a href="#Example_ScalarPaving">Example - Scalar Paving</a></li>
<li class="level2"><a href="#Example_Patch">Example - Patch Mesh Generation</a></li>
<li class="level2"><a href="#Check_Input">Checking Meshing Input for Errors</a></li>
<li class="level2"><a href="#Example_ConstantSmooth">Example - Smooth transition for constant size function</a></li>
<li class="level2"><a href="#Example_SizeFromDepth">Example - Generate size function from depth</a></li>
<li class="level2"><a href="#Example_SmoothSizeFunc">Example - Smooth a size function</a></li>
<li class="level2"><a href="#Example_Spring_Relax">Example - Spring relaxation</a></li>
<li class="level2"><a href="#Example_Quad_Blossom">Example - Triangular to quad mesh using Quad Blossom and Bad Quad Remover</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Meshing_Tutorial"></a>
Meshing Tutorial</h1>
<h2><a class="anchor" id="Intro_Meshing"></a>
Introduction</h2>
<p>The purpose of this tutorial is to provide explanation on how to use the classes defined in xmsmesh to generate meshes from input polygons. The examples provided in this tutorial refer to test cases that are in the <a class="el" href="_tut_meshing_8cpp.html">xmsmesh/tutorial/TutMeshing.cpp</a> source file.</p>
<h2><a class="anchor" id="Example_Simple_Polygon"></a>
Example - Simple Polygon</h2>
<p>This is the "hello world" example for using the meshing library.</p>
<p>This first example shows how to mesh a single polygon. The testing code for this example is TutMeshingTests::test_Example_SimplePolygon. A picture of the example is shown below. Notice that the polygon is a simple square from (0,0) to (100,100). Also notice that the point spacing along the boundary is a constant value of 10.</p>
<div class="image">
<img src="tutMesh_SimplePolygon_Input.png" alt="tutMesh_SimplePolygon_Input.png"/>
<div class="caption">
Simple Polygon with boundary spacing = 10.0</div></div>
<p> The basic steps to generate a mesh from a polygon are:</p><ol type="1">
<li>Define the polygon as a vector of points using the <a class="el" href="classxms_1_1_me_poly_input.html" title="Meshing inputs for one polygon. ">xms::MePolyInput</a> class.</li>
<li>Add the instance of the <a class="el" href="classxms_1_1_me_poly_input.html" title="Meshing inputs for one polygon. ">xms::MePolyInput</a> class to the m_polys vector of the xms::MeMultiPolyMesherInput class.</li>
<li>Pass the xms::MeMultiPolyMesherInput class to the <a class="el" href="classxms_1_1_me_multi_poly_to2dm.html" title="Creates a 2dm file of a mesh from polygons. ">xms::MeMultiPolyTo2dm</a>-&gt;Generate2dm method. This call will create an ascii file (2dm).</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a4bba234994c3b7fb4d6de2af0a93df28">TutMeshingIntermediateTests::test_Example_SimplePolygon</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_SimplePolygon&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_SimplePolygon</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this mesh can be found at test_files/Tutorial_Meshing/Example_SimplePolygon_base.2dm.</p>
<div class="image">
<img src="tutMesh_SimplePolygon_Output.png" alt="tutMesh_SimplePolygon_Output.png"/>
<div class="caption">
2d mesh generated from simple polygon with boundary spacing = 10.0</div></div>
 <h2><a class="anchor" id="Example_Complex_Polygon"></a>
Example - Complex Polygon</h2>
<p>This is another example of how to mesh a single polygon. The testing code for this example is TutMeshingTests::test_Example_ComplexPolygon. A picture of the example is shown below. Notice that the polygon is more complex than the first case. Similar to example 0, the point spacing along the boundary is a constant value of 10.</p>
<div class="image">
<img src="tutMesh_ComplexPolygon_Input.png" alt="tutMesh_ComplexPolygon_Input.png"/>
<div class="caption">
Complex Polygon with boundary spacing = 10.0</div></div>
<p> The same basic steps used with the simple polygon are followed for this example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#aca21ece58a116cc6e905cecded135763">TutMeshingIntermediateTests::test_Example_ComplexPolygon</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},    {0, 20},    {0, 30},    {0, 40},    {0, 50},    {0, 60},    {0, 70},    {0, 80},</div><div class="line">    {0, 90},    {0, 100},   {0, 110},   {0, 120},   {0, 130},   {0, 140},   {0, 150},   {0, 160},</div><div class="line">    {0, 170},   {0, 180},   {0, 190},   {0, 200},   {10, 200},  {20, 200},  {30, 200},  {40, 200},</div><div class="line">    {50, 200},  {60, 200},  {70, 200},  {80, 200},  {90, 200},  {100, 200}, {110, 200}, {120, 200},</div><div class="line">    {130, 200}, {140, 200}, {150, 200}, {160, 200}, {170, 200}, {180, 200}, {190, 200}, {200, 200},</div><div class="line">    {200, 190}, {200, 180}, {200, 170}, {200, 160}, {200, 150}, {200, 140}, {200, 130}, {200, 120},</div><div class="line">    {200, 110}, {200, 100}, {200, 90},  {200, 80},  {200, 70},  {200, 60},  {200, 50},  {200, 40},</div><div class="line">    {200, 30},  {200, 20},  {200, 10},  {200, 0},   {190, 0},   {180, 0},   {170, 0},   {160, 0},</div><div class="line">    {150, 0},   {140, 0},   {130, 0},   {120, 0},   {110, 0},   {110, 10},  {110, 20},  {110, 30},</div><div class="line">    {110, 40},  {120, 40},  {130, 40},  {140, 40},  {150, 40},  {150, 50},  {150, 60},  {150, 70},</div><div class="line">    {150, 80},  {150, 90},  {150, 100}, {150, 110}, {150, 120}, {150, 130}, {150, 140}, {150, 150},</div><div class="line">    {140, 150}, {130, 150}, {120, 150}, {110, 150}, {100, 150}, {90, 150},  {80, 150},  {70, 150},</div><div class="line">    {60, 150},  {50, 150},  {50, 140},  {50, 130},  {50, 120},  {50, 110},  {50, 100},  {50, 90},</div><div class="line">    {50, 80},   {50, 70},   {50, 60},   {50, 50},   {50, 40},   {60, 40},   {70, 40},   {80, 40},</div><div class="line">    {90, 40},   {90, 30},   {90, 20},   {90, 10},   {90, 0},    {80, 0},    {70, 0},    {60, 0},</div><div class="line">    {50, 0},    {40, 0},    {30, 0},    {20, 0},    {10, 0},    {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_ComplexPolygon&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_ComplexPolygon</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_ComplexPolygon_base.2dm</p>
<div class="image">
<img src="tutMesh_ComplexPolygon_Output.png" alt="tutMesh_ComplexPolygon_Output.png"/>
<div class="caption">
2d mesh generated from complex polygon with boundary spacing = 10.0</div></div>
 <h2><a class="anchor" id="Example_Complex_Polygon_Hole"></a>
Example - Simple Polygon with a hole</h2>
<p>This is another example of how to mesh a single polygon, but this polygon contains a hole. The testing code for this example is TutMeshingTests::test_Example_SimplePolygonWithHole. A picture of the example is shown below. This example still uses a constant point spacing of 10 along the boundary.</p>
<div class="image">
<img src="tutMesh_SimplePolygonWithHole_Input.png" alt="tutMesh_SimplePolygonWithHole_Input.png"/>
<div class="caption">
Simple Polygon with a hole and boundary spacing = 10.0</div></div>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a97aefc16612ebf834d3b306fc9d6b702">TutMeshingIntermediateTests::test_Example_SimplePolygonWithHole</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// Inner polygons are in counter clockwise order. Do not repeat the first</span></div><div class="line">  <span class="comment">// point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ada6e1927f7a333e15f487e89fd8551f9">m_insidePolys</a>.push_back(xms::VecPt3d());</div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ada6e1927f7a333e15f487e89fd8551f9">m_insidePolys</a>[0] = {{40, 40}, {50, 40}, {60, 40}, {60, 50},</div><div class="line">                                {60, 60}, {50, 60}, {40, 60}, {40, 50}};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_SimplePolygonWithHole&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_SimplePolygonWithHole</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_SimplePolygonWithHole_base.2dm</p>
<div class="image">
<img src="tutMesh_SimplePolygonWithHole_Output.png" alt="tutMesh_SimplePolygonWithHole_Output.png"/>
<div class="caption">
2d mesh generated from simple polygon with a hole and boundary spacing = 10.0</div></div>
 <h2><a class="anchor" id="Example_Breaklines"></a>
Example - Breaklines</h2>
<p>The next example has a polygon as well as a breakline. A breakline is a mulitsegment line within a polygon. The breakline may begin at one of the polygon points or it may be completely contained within the polygon. The edges of elements in the resulting mesh must conform to the segments of the breakline. The testing code for this example is TutMeshingTests::test_Example_Breakline. A picture of the example is shown below.</p>
<div class="image">
<img src="tutMesh_Breakline_Input.png" alt="tutMesh_Breakline_Input.png"/>
<div class="caption">
Simple Polygon with a breakline and boundary spacing = 10.0</div></div>
<p> Breaklines can be specified as an internal polygon with a width of 0.0. The points that make up the line are pushed into a vector from the beginning point in order to the endpoint and then back in order to the point just before the beginning point (see the definition of the inner polygon in the following example).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a766687c31cf21266280eee287b99e1ec">TutMeshingIntermediateTests::test_Example_Breakline</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// Inner polygons are in counter clockwise order. Do not repeat the first</span></div><div class="line">  <span class="comment">// point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ada6e1927f7a333e15f487e89fd8551f9">m_insidePolys</a>.push_back(xms::VecPt3d());</div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ada6e1927f7a333e15f487e89fd8551f9">m_insidePolys</a>[0] = {{50, 0}, {50, 10}, {50, 20}, {50, 10}};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_Breakline&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_Breakline</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_Breakline_base.2dm</p>
<div class="image">
<img src="tutMesh_Breakline_Output.png" alt="tutMesh_Breakline_Output.png"/>
<div class="caption">
2d mesh generated from simple polygon with a hole and boundary spacing = 10.0</div></div>
 <h2><a class="anchor" id="Example_RefinePoints"></a>
Example - Refine Points</h2>
<p>A refine point is a location in the mesh where the user can specify a desired element edge size. The generated mesh will have elements with the specified size surrounding the refine point. Refine points can be located at a mesh node/point (corner of a cell/element). Refine points can also be located at the center of a cell/element. A desired element edge size can also be specified with each refine point. If the size is not specified then the refine point becomes a "hard point" that is inserted as a node into the mesh. The following example includes all 3 types of refine points. The testing code for this example is TutMeshingTests::test_Example_RefinePoints. A picture of the example is shown below.</p>
<div class="image">
<img src="tutMesh_RefinePoints_Input.png" alt="tutMesh_RefinePoints_Input.png"/>
<div class="caption">
Simple Polygon with 3 refine points and boundary spacing = 10.0</div></div>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a242ca8d4ebf60cbaa22d5ef2fb75ccc7">TutMeshingIntermediateTests::test_Example_RefinePoints</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// Refine points are specified independent of polygons. The mesher will</span></div><div class="line">  <span class="comment">// determine the polygon that contains the point.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>.assign(3, <a class="code" href="classxms_1_1_me_refine_point.html">xms::MeRefinePoint</a>(xms::Pt3d(), -1, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <span class="comment">// specify a refine point where the point is at the cell center with</span></div><div class="line">  <span class="comment">// a desired size of 2</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[0].m_pt = xms::Pt3d(20, 20, 0);</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[0].m_createMeshPoint = <span class="keyword">false</span>;</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[0].m_size = 2.0;</div><div class="line"></div><div class="line">  <span class="comment">// specify a refine point where the point is at a mesh node with a</span></div><div class="line">  <span class="comment">// desired size of 7</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[1].m_pt = xms::Pt3d(20, 80, 0);</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[1].m_createMeshPoint = <span class="keyword">true</span>;</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[1].m_size = 5.0;</div><div class="line"></div><div class="line">  <span class="comment">// specify a &quot;hard point&quot;</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[2].m_pt = xms::Pt3d(80, 20, 0);</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>[2].m_size = -1;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_RefinePoints&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_RefinePoints</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_RefinePoints_base.2dm</p>
<div class="image">
<img src="tutMesh_RefinePoints_Output.png" alt="tutMesh_RefinePoints_Output.png"/>
<div class="caption">
2d mesh generated from simple polygon with 3 refine points and boundary spacing = 10.0</div></div>
 <h2><a class="anchor" id="Example_MultiPolygon"></a>
Example - Multiple Polygons with variable spacing, holes, breaklines, and refine points</h2>
<p>The next example has multiple polygons with variable spacing along the boundary, holes in the polygons, breaklines and refine points. The testing code for this example is TutMeshingTests::test_Example_MultiplePolygons. A picture of the example is shown below.</p>
<div class="image">
<img src="tutMesh_MultiPolygon_Input.png" alt="tutMesh_MultiPolygon_Input.png"/>
<div class="caption">
Multiple polygons with variable spacing, holes, breaklines, and refine points</div></div>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a73fe21b1441eef9c225046b073627f65">TutMeshingIntermediateTests::test_Example_MultiplePolygons</a>()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string path(std::string(XMS_TEST_PATH) + <span class="stringliteral">&quot;Tutorial_Meshing/&quot;</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname(path + <span class="stringliteral">&quot;Example_MultiPolys.txt&quot;</span>);</div><div class="line">  xms::VecPt3d3d inside;</div><div class="line">  xms::VecPt3d2d outside;</div><div class="line">  <span class="comment">// Read the polygons from a text file to avoid typing out all of the</span></div><div class="line">  <span class="comment">// coordinates</span></div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a628745f5e25428ed1e435e712ae741c1">xms::tutReadPolygons</a>(fname, outside, inside);</div><div class="line"></div><div class="line">  <span class="comment">// put the polygons into the meshing input class</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; outside.size(); ++i)</div><div class="line">  {</div><div class="line">    input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(<a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a>(outside[i], inside[i]));</div><div class="line">  }</div><div class="line">  <span class="comment">// add refine points to the meshing input</span></div><div class="line">  xms::Pt3d p0(80, 80, 0), p1(125, 125, 0);</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>.push_back(<a class="code" href="classxms_1_1_me_refine_point.html">xms::MeRefinePoint</a>(p0, -1.0, <span class="keyword">true</span>));</div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a3f1916f6cc658980525e9f2bc08b3818">m_refPts</a>.push_back(<a class="code" href="classxms_1_1_me_refine_point.html">xms::MeRefinePoint</a>(p1, 1.0, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_MultiPolys&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_MultiplePolygons</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_MultiPolygon_base.2dm</p>
<div class="image">
<img src="tutMesh_MultiPolygon_Output.png" alt="tutMesh_MultiPolygon_Output.png"/>
<div class="caption">
2d mesh generated from multiple polygons</div></div>
 <h2><a class="anchor" id="Example_ScalarPaving"></a>
Example - Scalar Paving</h2>
<p>This example illustrates how to influence the size of elements in the generated 2d mesh by specifying a size function. This process is referred to as scalar paving. The size function is specified using <a class="elRef" doxygen="/home/conan/Doxygen/xmsinterp.tag:https://aquaveo.github.io/xmsinterp/" href="https://aquaveo.github.io/xmsinterp/classxms_1_1_interp_base.html">xms::InterpBase</a>. The InterpBase class performs spatial interpolation from points and triangles. This example uses a simple polygon with a set of 5 points and 4 triangles to define a linear size function. The testing code for this example is TutMeshingTests::test_Example_ScalarPaving. A picture of the example is shown below.</p>
<div class="image">
<img src="tutMesh_ScalarPaving_Input.png" alt="tutMesh_ScalarPaving_Input.png"/>
<div class="caption">
Simple polygon with linear size function</div></div>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#af9d6182b721b7950d8ec2f46ba9160ba">TutMeshingIntermediateTests::test_Example_ScalarPaving</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// create a size function interpolator</span></div><div class="line"></div><div class="line">  <span class="comment">// These are the interpolator point locations. The size is specified by the</span></div><div class="line">  <span class="comment">// &quot;z&quot; component of the points.</span></div><div class="line">  BSHP&lt;xms::VecPt3d&gt; sPts(<span class="keyword">new</span> xms::VecPt3d());</div><div class="line">  *sPts = {{-10, -10, 10}, {-10, 110, 10}, {110, 110, 10}, {110, -10, 10}, {60, 70, 1}};</div><div class="line">  <span class="comment">// These are the interpolator triangles.</span></div><div class="line">  <span class="comment">// Triangles are specified as point indexes in ccw order.  You can see the</span></div><div class="line">  <span class="comment">// 4 triangles in the vector below.</span></div><div class="line">  BSHP&lt;xms::VecInt&gt; sTris(<span class="keyword">new</span> xms::VecInt());</div><div class="line">  *sTris = {0, 4, 1, 1, 4, 2, 2, 4, 3, 3, 4, 0};</div><div class="line">  <span class="comment">// create a linear interpolator for the size function</span></div><div class="line">  BSHP&lt;xms::InterpBase&gt; linear(<a class="codeRef" doxygen="/home/conan/Doxygen/xmsinterp.tag:https://aquaveo.github.io/xmsinterp/" href="https://aquaveo.github.io/xmsinterp/classxms_1_1_interp_linear.html#a8e04b96fee6e50961ba278d892373911">xms::InterpLinear::New</a>());</div><div class="line">  <span class="comment">// sets the points and the triangles for the interpolator</span></div><div class="line">  linear-&gt;SetPtsTris(sPts, sTris);</div><div class="line">  <span class="comment">// now set the size function on the mesh generator input class</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>[0].m_sizeFunction = linear;</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_ScalarPaving&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_ScalarPaving</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_ScalarPaving_base.2dm</p>
<div class="image">
<img src="tutMesh_ScalarPaving_Output.png" alt="tutMesh_ScalarPaving_Output.png"/>
<div class="caption">
2d mesh generated from simple polygon with size function</div></div>
 <h2><a class="anchor" id="Example_Patch"></a>
Example - Patch Mesh Generation</h2>
<p>An adaptive coons patch methodology is implemented in xmsmesh for generating triangular and quad cells. In general, a patch can be generated for a polygon with 4 sides. You can specify the four sides by indicating the indices of the points that make up the polygon corners in the <a class="el" href="classxms_1_1_me_poly_input.html" title="Meshing inputs for one polygon. ">xms::MePolyInput</a> class (m_polyCorners). Below is a picture of the input for this example. Notice that the number of segments is different on each side of the polygon. The testing code for this example is TutMeshingTests::test_Example_Patch.</p>
<div class="image">
<img src="tutMesh_Patch_Input.png" alt="tutMesh_Patch_Input.png"/>
<div class="caption">
Input polygon for patch mesh generation</div></div>
<p> The following code shows how to setup the polygon corners. Note that the first point listed in the polygons is assumed to be a corner and not included in the list of corners. Thus, m_polyCorners should always be either size 0 or 3.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a4cc20f4b834919dd705b4a6724abb1f9">TutMeshingIntermediateTests::test_Example_Patch</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {{0, 0},    {0, 10},    {0, 20},   {0, 30},   {0, 40},   {0, 60},</div><div class="line">                         {0, 70},   {0, 80},    {0, 90},   {0, 100},  {20, 100}, {40, 100},</div><div class="line">                         {60, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">                         {100, 50}, {100, 40},  {100, 30}, {100, 20}, {100, 10}, {100, 0},</div><div class="line">                         {85, 0},   {70, 0},    {55, 0},   {40, 0},   {25, 0},   {10, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// Specify the polygon corners. It is assumed that the first point above is</span></div><div class="line">  <span class="comment">// one of the corners so we specify the other 3 corners.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#af922303af2f65d7f64958fd06279f913">m_polyCorners</a> = {9, 13, 23};</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_Patch&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_Patch</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_Patch_base.2dm</p>
<div class="image">
<img src="tutMesh_Patch_Output.png" alt="tutMesh_Patch_Output.png"/>
<div class="caption">
2d mesh generated using the patch algorithm</div></div>
 <h2><a class="anchor" id="Check_Input"></a>
Checking Meshing Input for Errors</h2>
<p>The input to the meshing algorithm is done using the xms::MeMultiPolyMesherInput class and the input must be specified in a certain way. For example, vectors defining outer polygons must not be empty, the first point should not be repeated as the last point, and the number of patch corners should be 0 or 3. The function MeMultiPolyMesherImpl::ValidateInput always checks the input for these simple errors before the meshing is performed. If errors are found, the mesher asserts, writes the errors to a log file, and aborts.</p>
<p>Additionally, no polygon should intersect with any other polygon. A check for polygon intersections can be performed if the xms::MeMultiPolyMesherInput::m_checkTopology variable is set to true. Checking for intersections can take a long time if the input includes many polygons, so this variable is false by default. Again, if errors are found, the mesher asserts, writes the errors to a log file, and aborts.</p>
<p>Despite these checks, it is still possible to give the mesher bad input, and additional checks could be added in the future. For example, checks that outer polygons are clockwise and inner polygons are counter-clockwise and no inner polygon is outside it's outer polygon could be added.</p>
<h2><a class="anchor" id="Example_ConstantSmooth"></a>
Example - Smooth transition for constant size function</h2>
<p>This example shows how to specify a constant size function on a polygon that will smoothly transition from the spacing of points along the boundary to the specified constant size. This is specified in the <a class="el" href="classxms_1_1_me_poly_input.html" title="Meshing inputs for one polygon. ">xms::MePolyInput</a> class. The size is specified in the m_constSizeFunction variable and a bias is specified in the m_constSizeBias member. To transition as fast as possible between boundary spacing and the m_constSizeFunction set the bias to 1.0 to transition as slowly as possible set the bias to 0.0. The testing code for this example is in TutMeshingTests::test_Example_ConstantSmooth. The input polygon is shown below.</p>
<div class="image">
<img src="tutMesh_SimplePolygon_Input.png" alt="tutMesh_SimplePolygon_Input.png"/>
<div class="caption">
Simple Polygon with boundary spacing = 10.0</div></div>
<p> The test shows having the size transition from the boundary spacing of 10.0 to a size of 1.0 and then a second example where the size transitions to 50.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#ab3096f420b245110a335ec3929416400">TutMeshingIntermediateTests::test_Example_ConstantSmooth</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// specify a constant size function</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#a8f7fbf25af31e2750c0790d54e5293c6">m_constSizeFunction</a> = 1.0;</div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#aca43fb2091a846525c1ce79551e63b54">m_constSizeBias</a> = 0.2;</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_ConstantSmooth&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line"></div><div class="line">  <span class="comment">// now make the polygon grow to a bigger size element</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.front().m_constSizeFunction = 50;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string baseFile2 = <span class="stringliteral">&quot;Example_ConstantSmooth2&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile2);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_ConstantSmooth</span></div></div><!-- fragment --><p> An image of the two 2d meshs is shown below. The *.2dm file for the output 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_ConstantSmooth_base.2dm and Example_ConstantSmooth1_base.2dm.</p>
<div class="image">
<img src="tutMesh_ConstantSmooth_Output.png" alt="tutMesh_ConstantSmooth_Output.png"/>
<div class="caption">
2d meshs generated by transitioning from boundary spacing to constant size</div></div>
 <h2><a class="anchor" id="Example_SizeFromDepth"></a>
Example - Generate size function from depth</h2>
<p>This example shows how use use xms::meSizeFunctionFromDepth to generate a size function from depth measured at points. The user specifies an array of depths and a min element size and a max element size then an array is filled with the sizes. The testing code for this example is in TutMeshingTests::test_Example_SizeFuncFromDepth.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a18ecf6b96514984d40f296590550b4c2">TutMeshingIntermediateTests::test_Example_SizeFuncFromDepth</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// array of depths</span></div><div class="line">  xms::VecDbl depths = {0, 5, 10, 20, 25, 5, 0};</div><div class="line">  <span class="comment">// array for the computed sizes</span></div><div class="line">  xms::VecDbl elemSize;</div><div class="line">  <span class="comment">// set the value of the min and max element size</span></div><div class="line">  <span class="keywordtype">double</span> minElem(2), maxElem(102);</div><div class="line">  <span class="comment">// generate the size array</span></div><div class="line">  <a class="code" href="_me_mesh_utils_8cpp.html#a29eec2a008fa0ec0239a63d043cecde3">xms::meSizeFunctionFromDepth</a>(depths, elemSize, minElem, maxElem);</div><div class="line">  <span class="comment">// verify that the sizes are as expected</span></div><div class="line">  xms::VecDbl baseElemSize = {2, 22, 42, 82, 102, 22, 2};</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore/" href="https://aquaveo.github.io/xmscore/_test_tools_8h.html#aa093335ed24e9478f11c0ab037a21597">TS_ASSERT_DELTA_VEC</a>(baseElemSize, elemSize, 1e-9);</div><div class="line"></div><div class="line">  <span class="comment">// now create an interpolator to pass along to a mesher</span></div><div class="line"></div><div class="line">  <span class="comment">// init the locations of the points used to interpolate</span></div><div class="line">  BSHP&lt;xms::VecPt3d&gt; pts(<span class="keyword">new</span> xms::VecPt3d());</div><div class="line">  *pts = {{10, 10}, {25, 10}, {10, 25}, {50, 10}, {50, 25}, {50, 50}, {25, 50}};</div><div class="line">  BSHP&lt;xms::VecInt&gt; tris(<span class="keyword">new</span> xms::VecInt());</div><div class="line"></div><div class="line">  <span class="comment">// convert the sizes to a float array for the interpolator</span></div><div class="line">  xms::VecFlt sizeFlt(elemSize.size(), 0);</div><div class="line">  <span class="keywordtype">int</span> i(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; d : elemSize)</div><div class="line">    sizeFlt[i++] = (float)d;</div><div class="line"></div><div class="line">  <span class="comment">// create an IDW interpolator</span></div><div class="line">  BSHP&lt;xms::InterpBase&gt; interp = <a class="codeRef" doxygen="/home/conan/Doxygen/xmsinterp.tag:https://aquaveo.github.io/xmsinterp/" href="https://aquaveo.github.io/xmsinterp/classxms_1_1_interp_idw.html#ada220d36126708676e57d6b9eac2f3d7">xms::InterpIdw::New</a>();</div><div class="line">  interp-&gt;SetPtsTris(pts, tris);</div><div class="line"></div><div class="line">  <span class="comment">// now the interpolator could be used with a mesher</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> poly;</div><div class="line">  poly.<a class="code" href="classxms_1_1_me_poly_input.html#aa30944b8fb5e3e176c595ca812781290">m_sizeFunction</a> = interp;</div><div class="line"></div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_SizeFuncFromDepth</span></div></div><!-- fragment --> <h2><a class="anchor" id="Example_SmoothSizeFunc"></a>
Example - Smooth a size function</h2>
<p>This example shows how to smooth a size function based on geometric proximity so that element creation from the size function will satisfy an element growth/reduction factor. For example, if a size function specifies a nodal spacing of 10 meter elements at one location and 100 meter elements at another location 20 meters away then these constraints conflict. The smoothing function can reduce the 100 or increase the 10 based on the parameters passed to the function. The testing code for this example is in TutMeshingTests::test_Example_SmoothSizeFunc.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#ad2f8db20610932f74a4c721016ad8539">TutMeshingIntermediateTests::test_Example_SmoothSizeFunc</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// create a grid of points</span></div><div class="line">  BSHP&lt;xms::VecPt3d&gt; pts(<span class="keyword">new</span> xms::VecPt3d());</div><div class="line">  *pts = {{0, 0},   {10, 0},  {20, 0}, {30, 0},  {0, 10},  {10, 10},</div><div class="line">          {20, 10}, {30, 10}, {0, 20}, {10, 20}, {20, 20}, {30, 20}};</div><div class="line">  <span class="comment">// assign all points a size of 100</span></div><div class="line">  xms::VecFlt sizes(pts-&gt;size(), 100);</div><div class="line">  <span class="comment">// change the size to 1.0 of the point at 0, 10</span></div><div class="line">  sizes[4] = 1;</div><div class="line">  <span class="comment">// create a TrTin class from the array of points</span></div><div class="line">  BSHP&lt;xms::VecInt&gt; tris(<span class="keyword">new</span> xms::VecInt());</div><div class="line">  BSHP&lt;xms::VecInt2d&gt; adjTris(<span class="keyword">new</span> xms::VecInt2d());</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmsinterp.tag:https://aquaveo.github.io/xmsinterp/" href="https://aquaveo.github.io/xmsinterp/classxms_1_1_tr_triangulator_points.html">xms::TrTriangulatorPoints</a> tr(*pts, *tris, &amp;*adjTris);</div><div class="line">  tr.Triangulate();</div><div class="line">  BSHP&lt;xms::TrTin&gt; tin = <a class="codeRef" doxygen="/home/conan/Doxygen/xmsinterp.tag:https://aquaveo.github.io/xmsinterp/" href="https://aquaveo.github.io/xmsinterp/classxms_1_1_tr_tin.html#ab1227a106b70c3061bd03cb3fb9833a7">xms::TrTin::New</a>();</div><div class="line">  tin-&gt;SetGeometry(pts, tris, adjTris);</div><div class="line"></div><div class="line">  <span class="comment">// smooth the size function. The size ratio is set to 0.5. The min element</span></div><div class="line">  <span class="comment">// size is 1.0. The &quot;anchor type&quot; is 0 (meaning min). This means the minimum</span></div><div class="line">  <span class="comment">// size will be honored and the other values smoothed from the min.</span></div><div class="line">  xms::VecFlt vSmooth;</div><div class="line">  xms::DynBitset ptFlgs;</div><div class="line">  <a class="code" href="_me_mesh_utils_8cpp.html#abb4b34e0e4cbae7cce74281e4af03d74">xms::meSmoothSizeFunction</a>(tin, sizes, 0.5, 1.0, 0, ptFlgs, vSmooth);</div><div class="line">  xms::VecFlt baseSmooth = {4.46f, 5.90f,  9.36f, 12.83f, 1.0f,   4.46f,</div><div class="line">                            7.93f, 11.39f, 4.46f, 7.93f,  11.39f, 14.86f};</div><div class="line">  <span class="comment">// ensure the results are as expected</span></div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore/" href="https://aquaveo.github.io/xmscore/_test_tools_8h.html#aa093335ed24e9478f11c0ab037a21597">TS_ASSERT_DELTA_VEC</a>(baseSmooth, vSmooth, .1);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_SmoothSizeFunc</span></div></div><!-- fragment --> <h2><a class="anchor" id="Example_Spring_Relax"></a>
Example - Spring relaxation</h2>
<p>This is another example of how to mesh a single polygon with a hole, and in this example, we use the "spring relaxation" method for relaxing the mesh nodes after the initial point seeding is completed. The testing code for this example is <a class="el" href="class_tut_meshing_intermediate_tests.html#a248c0b0b4537aa1557488deca36d6fb0" title="[snip_test_Example_SmoothSizeFunc] ">TutMeshingIntermediateTests::test_Example_SpringRelax</a>. A picture of the example is shown below. This example still uses a constant point spacing of 10 along the boundary.</p>
<div class="image">
<img src="tutMesh_SimplePolygonWithHole_Input.png" alt="tutMesh_SimplePolygonWithHole_Input.png"/>
<div class="caption">
Simple Polygon with a hole and boundary spacing = 10.0</div></div>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a248c0b0b4537aa1557488deca36d6fb0">TutMeshingIntermediateTests::test_Example_SpringRelax</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// The MePolyInput class defines a single polygon to be meshed and which</span></div><div class="line">  <span class="comment">// consists of one outer polygon and, optionally, inner polygons and some</span></div><div class="line">  <span class="comment">// other options.</span></div><div class="line">  <a class="code" href="classxms_1_1_me_poly_input.html">xms::MePolyInput</a> inputPoly;</div><div class="line"></div><div class="line">  <span class="comment">// Outer polygon points are in clockwise order. Do not repeat the first point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ad85860ecd7ab18a60f29ceb9a2fc99fc">m_outPoly</a> = {</div><div class="line">    {0, 10},   {0, 20},   {0, 30},   {0, 40},    {0, 50},   {0, 60},   {0, 70},   {0, 80},</div><div class="line">    {0, 90},   {0, 100},  {10, 100}, {20, 100},  {30, 100}, {40, 100}, {50, 100}, {60, 100},</div><div class="line">    {70, 100}, {80, 100}, {90, 100}, {100, 100}, {100, 90}, {100, 80}, {100, 70}, {100, 60},</div><div class="line">    {100, 50}, {100, 40}, {100, 30}, {100, 20},  {100, 10}, {100, 0},  {90, 0},   {80, 0},</div><div class="line">    {70, 0},   {60, 0},   {50, 0},   {40, 0},    {30, 0},   {20, 0},   {10, 0},   {0, 0}};</div><div class="line"></div><div class="line">  <span class="comment">// Inner polygons are in counter clockwise order. Do not repeat the first</span></div><div class="line">  <span class="comment">// point.</span></div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ada6e1927f7a333e15f487e89fd8551f9">m_insidePolys</a>.push_back(xms::VecPt3d());</div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#ada6e1927f7a333e15f487e89fd8551f9">m_insidePolys</a>[0] = {{40, 40}, {50, 40}, {60, 40}, {60, 50},</div><div class="line">                                {60, 60}, {50, 60}, {40, 60}, {40, 50}};</div><div class="line">  inputPoly.<a class="code" href="classxms_1_1_me_poly_input.html#a90f4f6fcebbdddef0bb468250f9e75cc">m_relaxationMethod</a> = <span class="stringliteral">&quot;spring_relaxation&quot;</span>;</div><div class="line"></div><div class="line">  <span class="comment">// The MeMultiPolyMesherIo class holds all the options for generating</span></div><div class="line">  <span class="comment">// UGrids from polygon data</span></div><div class="line">  <a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html">xms::MeMultiPolyMesherIo</a> input;</div><div class="line"></div><div class="line">  <span class="comment">// The m_polys vector holds the polygons that will be filled with a UGrid.</span></div><div class="line">  <span class="comment">// This case has only 1 polygon.</span></div><div class="line">  input.<a class="code" href="classxms_1_1_me_multi_poly_mesher_io.html#a0bb7270c90ac0115140d38b6b3670e08">m_polys</a>.push_back(inputPoly);</div><div class="line"></div><div class="line">  <span class="comment">// generate the mesh and check the base line</span></div><div class="line">  <span class="keyword">const</span> std::string baseFile = <span class="stringliteral">&quot;Example_SpringRelax&quot;</span>;</div><div class="line">  <a class="code" href="_tut_meshing_8cpp.html#a9db0e37fd5930a52e63761e6e6274747">tutGenerateAndCompare2dm</a>(input, baseFile);</div><div class="line">} <span class="comment">// TutMeshingIntermediateTests::test_Example_SpringRelax</span></div></div><!-- fragment --><p> An image of the 2d mesh generated from this example is shown below. The *.2dm file for this 2d mesh can be found at files_xmsmesh/Test/Tutorial_Meshing/Example_SpringRelax_base.2dm.</p>
<div class="image">
<img src="tutMesh_SpringRelax_Output.png" alt="tutMesh_SpringRelax_Output.png"/>
<div class="caption">
2d mesh generated from simple polygon with a hole and boundary spacing = 10.0, using spring relaxation</div></div>
 <h2><a class="anchor" id="Example_Quad_Blossom"></a>
Example - Triangular to quad mesh using Quad Blossom and Bad Quad Remover</h2>
<p>This is an experimental feature that is not supported in the public interface.</p>
<p>This example shows how to convert a triangular mesh to a quad mesh using the Quad Blossom algorithm. Then the <a class="el" href="classxms_1_1_me_bad_quad_remover.html">xms::MeBadQuadRemover</a> class is used to remove narrow, ill-formed quads while still preserving the basic sizes of cells.</p>
<p>There are two arguments to MeQuadBlossom::MakeQuads(). The first is a bool: splitVertices. If this is false, the algorithm will not attempt to match triangles on the boundary that share a boundary point but not an edge; that is, there is at least one other triangle between them that also shares that boundary point. So by setting this argument to false, you may be left with more than one triangle in the mesh, even if the number of boundary edges is even. If this argument is true, it will match such triangles and then turn them into quads by adding a new point on the interior of the mesh and an edge between that point and the boundary point. The two matching boundary triangles will add and share that edge, thus becoming quads. If the number of triangles incident to the boundary point to be split is odd, the new point is placed at the centroid of the middle triangle; if even, it is at the mid-point of the middle edge. The other cells incident to the boundary point will swap to use the new split point instead. So with this argument set to true, you may see some added points in the output ugrid. Internally, the algorithm weights the match on such adjacent boundary triangles lower than any interior edges, so the interior edges will get matched and eliminated before splitting any boundary points to form new edges. If set to false, the output quad cells will just be the result of removing prior interior edges so that pairs of triangles become quads. <br />
 The second argument is also a bool: useAngle. There are two internal methods used to associate a weight for each interior edge (between adjacent triangles). Both methods are based on the quad that would be formed by eliminating that edge. If useAngle is true, the weight is based on the interior angles of the quad (and in particular the one farthest from being a right angle. If false, the weight is based on the ratio of the sum of the squares of the lengths of each pair of adjacent sides to the length of their corresponding diagonal squared. Again, it ends up being based on the angle with the maximum deviation from 90 degrees. In both cases, we multiply the floating point weight (that is between 0 and 1) by 1,000 to get an integer weight between 0 and 1,000. (The weights between boundary triangles that might be split are all set to -10.) In general, the closer the quad is to rectangular, the closer the weight is to the maximum, and as the aspect ratio gets larger, the closer the weight gets to zero. They produce slightly different results, but we don't have enough experience yet to recommend one over the other.</p>
<p>Also, note that the algorithm is O(N^3) with respect to the number of points in the mesh. Hence, we provide a function to estimate the runtime. In general, if your mesh has over a 2,000 points, you should split it at convenient boundaries to get below that limit and then run the algorithm on each submesh. You should get no triangles in the result if the sum of all of the boundary edges is an even number and you set splitVertices to true. The main purpose of PreMakeQuads() is to find the edges and return the number of boundary edges, so you can check that it is even. This is demonstrated in the example below.</p>
<div class="image">
<img src="tutMesh_QuadBlossom_Input.png" alt="tutMesh_QuadBlossom_Input.png"/>
<div class="caption">
Triangular mesh input to Quad Blossom algorithm</div></div>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/conan/Doxygen/xmsgrid.tag:https://aquaveo.github.io/xmsgrid/" href="https://aquaveo.github.io/xmsgrid/_xm_u_grid_8h.html">xmsgrid/ugrid/XmUGrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/conan/Doxygen/xmsgrid.tag:https://aquaveo.github.io/xmsgrid/" href="https://aquaveo.github.io/xmsgrid/_xm_u_grid_utils_8h.html">xmsgrid/ugrid/XmUGridUtils.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_me_quad_blossom_8h.html">xmsmesh/meshing/detail/MeQuadBlossom.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_me_bad_quad_remover_8h.html">xmsmesh/meshing/detail/MeBadQuadRemover.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_tut_meshing_intermediate_tests.html#a4e77cbc32699681a269adbe9c3d23cfa">TutMeshingIntermediateTests::test_Example_QuadBlossom_BadQuadRemover</a>()</div><div class="line">{</div><div class="line">  <span class="comment">// read a UGrid from a file.</span></div><div class="line">  <span class="keyword">const</span> std::string path(std::string(XMS_TEST_PATH) + </div><div class="line">                         <span class="stringliteral">&quot;Tutorial_Meshing/&quot;</span>);</div><div class="line">  <span class="keyword">const</span> std::string inputFilePath = path + <span class="stringliteral">&quot;Example_QuadBlossom_triangleUGridInput.txt&quot;</span>;</div><div class="line">  BSHP&lt;xms::XmUGrid&gt; ugrid = <a class="codeRef" doxygen="/home/conan/Doxygen/xmsgrid.tag:https://aquaveo.github.io/xmsgrid/" href="https://aquaveo.github.io/xmsgrid/namespacexms.html#a92b5c5c0a9e2455db6d671eb7134a76e">xms::XmReadUGridFromAsciiFile</a>(inputFilePath); <span class="comment">// read from file.</span></div><div class="line">  BSHP&lt;xms::MeQuadBlossom&gt; quadBlossom = <a class="code" href="classxms_1_1_me_quad_blossom.html#a43b266a9440b9227018450fcdce8050b">xms::MeQuadBlossom::New</a>(ugrid);</div><div class="line"></div><div class="line">  <span class="comment">// PreMakeQuads returns the number of boundary edges of the triangular mesh.</span></div><div class="line">  <span class="comment">// An even number of boundary edges insures no triangles in the output UGrid. </span></div><div class="line">  <span class="keywordtype">int</span> nBoundaryEdges = quadBlossom-&gt;PreMakeQuads();</div><div class="line">  TS_ASSERT((nBoundaryEdges &amp; 0x1) == 0); </div><div class="line"></div><div class="line">  <span class="comment">// The MeQuadBlossom basic algorithm is O(N^3). Check the estimated minutes.  If too large,</span></div><div class="line">  <span class="comment">// Then split the mesh into smaller sub-UGrids, then call MakeQuads on each one.</span></div><div class="line">  <span class="keywordtype">double</span> minutes = <a class="code" href="classxms_1_1_me_quad_blossom.html#a2b7a90fb4e78a40f0b12336d4b1f8eda">xms::MeQuadBlossom::EstimatedRunTimeInMinutes</a>(ugrid-&gt;GetPointCount());</div><div class="line">  TS_ASSERT(minutes &lt; 2.0);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> splitVertices = <span class="keyword">true</span>;</div><div class="line">  <span class="keywordtype">bool</span> useAngle = <span class="keyword">false</span>;</div><div class="line">  BSHP&lt;xms::XmUGrid&gt; quadUGrid = quadBlossom-&gt;MakeQuads(splitVertices, useAngle);</div><div class="line"></div><div class="line">  <span class="comment">// Test the quad UGrid generated by the Quad Blossom algorithm</span></div><div class="line">  <span class="keyword">const</span> std::string outFile = path + <span class="stringliteral">&quot;Example_QuadBlossom_quadUGrid_out.txt&quot;</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmsgrid.tag:https://aquaveo.github.io/xmsgrid/" href="https://aquaveo.github.io/xmsgrid/namespacexms.html#aad684d8d566604305a00cc4d875dd51e">xms::XmWriteUGridToAsciiFile</a>(quadUGrid, outFile);</div><div class="line">  <span class="keyword">const</span> std::string baseFile = path + <span class="stringliteral">&quot;Example_QuadBlossom_quadUGrid_base.txt&quot;</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore/" href="https://aquaveo.github.io/xmscore/_test_tools_8h.html#a910e81903f66d29dc334d1ed7c57ca5d">TS_ASSERT_TXT_FILES_EQUAL</a>(baseFile, outFile);</div><div class="line"></div><div class="line">  <span class="comment">// Use MeBadQuadRemover to remove bad quads from the quad UGrid.</span></div><div class="line">  <span class="keywordtype">double</span> maxAspect = 0.7;</div><div class="line">  BSHP&lt;xms::MeBadQuadRemover&gt; badQuadRemover = <a class="code" href="classxms_1_1_me_bad_quad_remover.html#a0252afc98457abd29b12b8716cd512be">xms::MeBadQuadRemover::New</a>(quadUGrid);</div><div class="line">  BSHP&lt;xms::XmUGrid&gt; quadUGridImproved = badQuadRemover-&gt;RemoveBadQuads(maxAspect);</div><div class="line"></div><div class="line">  <span class="comment">// Test the improved quad UGrid returned from the Bad Quad Remover algorithm</span></div><div class="line">  <span class="keyword">const</span> std::string outFile2 = path + <span class="stringliteral">&quot;Example_QuadBlossom_quadUGridImproved_out.txt&quot;</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmsgrid.tag:https://aquaveo.github.io/xmsgrid/" href="https://aquaveo.github.io/xmsgrid/namespacexms.html#aad684d8d566604305a00cc4d875dd51e">xms::XmWriteUGridToAsciiFile</a>(quadUGridImproved, outFile2);</div><div class="line">  <span class="keyword">const</span> std::string baseFile2 = path + <span class="stringliteral">&quot;Example_QuadBlossom_quadUGridImproved_base.txt&quot;</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore/" href="https://aquaveo.github.io/xmscore/_test_tools_8h.html#a910e81903f66d29dc334d1ed7c57ca5d">TS_ASSERT_TXT_FILES_EQUAL</a>(baseFile2, outFile2);</div><div class="line"></div><div class="line">  <span class="comment">// Use MeBadQuadRemover to remove bad quads from the quad UGrid a second time.</span></div><div class="line">  maxAspect = 0.7;</div><div class="line">  badQuadRemover = <a class="code" href="classxms_1_1_me_bad_quad_remover.html#a0252afc98457abd29b12b8716cd512be">xms::MeBadQuadRemover::New</a>(quadUGridImproved);</div><div class="line">  BSHP&lt;xms::XmUGrid&gt; quadUGridImproved2 = badQuadRemover-&gt;RemoveBadQuads(maxAspect);</div><div class="line"></div><div class="line">  <span class="comment">// Test the improved quad UGrid returned from the Bad Quad Remover algorithm</span></div><div class="line">  <span class="keyword">const</span> std::string outFile3 = path + <span class="stringliteral">&quot;Example_QuadBlossom_quadUGridImproved2_out.txt&quot;</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmsgrid.tag:https://aquaveo.github.io/xmsgrid/" href="https://aquaveo.github.io/xmsgrid/namespacexms.html#aad684d8d566604305a00cc4d875dd51e">xms::XmWriteUGridToAsciiFile</a>(quadUGridImproved2, outFile3);</div><div class="line">  <span class="keyword">const</span> std::string baseFile3 = path + <span class="stringliteral">&quot;Example_QuadBlossom_quadUGridImproved2_base.txt&quot;</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/conan/Doxygen/xmscore.tag:https://aquaveo.github.io/xmscore/" href="https://aquaveo.github.io/xmscore/_test_tools_8h.html#a910e81903f66d29dc334d1ed7c57ca5d">TS_ASSERT_TXT_FILES_EQUAL</a>(baseFile3, outFile3);</div><div class="line">}  <span class="comment">// TutMeshingIntermediateTests::test_Example_QuadBlossom_BadQuadRemover</span></div></div><!-- fragment --> <div class="image">
<img src="tutMesh_QuadBlossom_Output.png" alt="tutMesh_QuadBlossom_Output.png"/>
<div class="caption">
Output mesh input after running Quad Blossom algorithm</div></div>
 <div class="image">
<img src="tutMesh_QuadBlossom_BadQuadRemover_Output.png" alt="tutMesh_QuadBlossom_BadQuadRemover_Output.png"/>
<div class="caption">
Output mesh input after running Quad Blossom and Bad Quad Remover first time</div></div>
 <div class="image">
<img src="tutMesh_QuadBlossom_BadQuadRemover_Output2.png" alt="tutMesh_QuadBlossom_BadQuadRemover_Output2.png"/>
<div class="caption">
Output mesh input after running Bad Quad Remover second time</div></div>
<p> Running an angle relaxer should improve the mesh even more. As shown, you can remove bad quads several times, but each time will result in larger quads. It isn't clear that several such runs significantly improves the mesh. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 22 2019 16:56:17 for xmsmesh by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
